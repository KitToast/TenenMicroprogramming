
=================== Simulator Command Section =====================

Memory Dump Trace: 7
Maximum Simulation Cycle: 10000


=================== Micro Memory Section =====================

    :   c  i a     s            c    b    a          : 
    :   o  n m  a  h mm    e    c    b    a          : 
  l :   n  t u  l  f ba rw n    c    b    a          : 
  c :   d  r x  u  t rr dr c    c    b    a    addr4 : 
--- : --- -- - -- -- -- -- - ---- ---- ---- -------- : 

    :   c  i a     s            c    b    a         
    :   o  n m  a  h mm    e    c    b    a         
    :   n  t u  l  f ba rw n    c    b    a         
    :   d  r x  u  t rr dr c    c    b    a    addr4
    : --- -- - -- -- -- -- - ---- ---- ---- --------
  0 : 011 00 0 00 00 00 00 1 0000 0101 0101 00000011 :  pc := (  0+  0); 
    :                                                : JMP    3;
    * 
    : start of loop (read loop)
    : Interrupts
  3 : 000 01 0 00 00 00 00 0 0000 0000 0000 11001000 : JINTR 1  200; 
    :  000 10 0 00 00 00 00 0 0000 0000 0000 11001110
    :  000 11 0 00 00 00 00 0 0000 0000 0000 11011001
    : Read loop
  4 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
  5 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
  6 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
  7 : 000 00 1 00 00 00 00 1 0011 0101 0000 00000000 :  ir := (mbr+  0); 
  8 : 011 00 0 00 00 00 00 1 0000 0110 0000 00001010 :  pc := ( pc+ +1); 
    :                                                : JMP   10;
    : Check Op Codes 
    * 
    : Checks First Two bits. Goes to next line if 00 and branches to line 14 if 01 
 10 : 100  00001011   00001110   01101101   10011001 : JIR[7:6]  11  14 109 153
    : Checks bits 5 and 4 of Mac0. Goes to ADD intruction if 11 and SUB if 10, Goes to 12 if 00  
 11 : 101  00001100   00000000   00110111   00101101 : JIR[5:4]  12   0  55  45
    : Checks if bits 2 and 3 are 00 01 10 11. Goes to 13 if 00, Goes to 15 if 01 . Goes to 70 if 10 (BRR), Goes to 87 if TST  
 12 : 110  00001101   00001111   01000110   01010111 : JIR[3:2]  13  15  70  87
    : Checks bits 0 and 1.   
 13 : 111  11111111   00010010   00010010   00010010 : JIR[1:0] 255  18  18  18
    * 
    : Checks bits 5 and 4 if bits 7 and 6 are 0 1 respectively. Branches to 28 if 01 (CLR), to 31 if NEG, 40 if INC, 
 14 : 101  01001011   00011010   00011111   00101000 : JIR[5:4]  75  26  31  40
    * 
    : Checks the 0 and 1 bit if bits 5 and 4 of the instruction are 01. If bits 0 and 1 are 00, jump to 20 (BR). If 01, then jump to 80. 
 15 : 111  00010100   01010000   01010010   01010100 : JIR[1:0]  20  80  82  84

    * 
    : NOP operation 
 18 : 011 00 0 00 00 00 00 0 0000 0000 0000 00000011 : JMP    3;
    * 
    : Branches (BR) 
 20 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
 21 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
 22 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
 23 : 000 00 1 00 00 00 00 1 1000 0101 0000 00000000 :  t1 := (mbr+  0); 
 24 : 011 00 0 00 00 00 00 1 0000 0101 1000 00000011 :  pc := ( t1+  0); 
    :                                                : JMP    3;
    * 
    : Checks what bits 3 and 2 correspond to which register. Goes to 27 if 00, goes to 28 if 01 ..... goes to 30 if 11 (CLR)  
 26 : 110  00011011   00011100   00011101   00011110 : JIR[3:2]  27  28  29  30
 27 : 011 00 0 00 00 00 00 1 1100 0101 0101 00000011 : gr0 := (  0+  0); 
    :                                                : JMP    3;
 28 : 011 00 0 00 00 00 00 1 1101 0101 0101 00000011 : gr1 := (  0+  0); 
    :                                                : JMP    3;
 29 : 011 00 0 00 00 00 00 1 1110 0101 0101 00000011 : gr2 := (  0+  0); 
    :                                                : JMP    3;
 30 : 011 00 0 00 00 00 00 1 1111 0101 0101 00000011 : gr3 := (  0+  0); 
    :                                                : JMP    3;
    * 
    : Checks which general register bits 3 and 2 correspond to. Jumps to corresponding line and does 2s complement operation (NEG)
 31 : 110  00100000   00100010   00100100   00100110 : JIR[3:2]  32  34  36  38
 32 : 000 00 0 11 00 00 00 1 1100 0101 1100 00000000 : gr0 := (gr0 NOT); 
 33 : 011 00 0 00 00 00 00 1 1100 1100 0110 00000011 : gr0 := ( +1+gr0); 
    :                                                : JMP    3;
 34 : 000 00 0 11 00 00 00 1 1101 0101 1101 00000000 : gr1 := (gr1 NOT); 
 35 : 011 00 0 00 00 00 00 1 1101 1101 0110 00000011 : gr1 := ( +1+gr1); 
    :                                                : JMP    3;
 36 : 000 00 0 11 00 00 00 1 1110 0101 1110 00000000 : gr2 := (gr2 NOT); 
 37 : 011 00 0 00 00 00 00 1 1110 1110 0110 00000011 : gr2 := ( +1+gr2); 
    :                                                : JMP    3;
 38 : 000 00 0 11 00 00 00 1 1111 0101 1111 00000000 : gr3 := (gr3 NOT); 
 39 : 011 00 0 00 00 00 00 1 1111 1111 0110 00000011 : gr3 := ( +1+gr3); 
    :                                                : JMP    3;
    * 
    : Checks what general register bits 3 and 2 correspond to. Jumps to corresponding line and increments  (INC)
 40 : 110  00101001   00101010   00101011   00101100 : JIR[3:2]  41  42  43  44
 41 : 011 00 0 00 00 00 00 1 1100 1100 0110 00000011 : gr0 := ( +1+gr0); 
    :                                                : JMP    3;
 42 : 011 00 0 00 00 00 00 1 1101 1101 0110 00000011 : gr1 := ( +1+gr1); 
    :                                                : JMP    3;
 43 : 011 00 0 00 00 00 00 1 1110 1110 0110 00000011 : gr2 := ( +1+gr2); 
    :                                                : JMP    3;
 44 : 011 00 0 00 00 00 00 1 1111 1111 0110 00000011 : gr3 := ( +1+gr3); 
    :                                                : JMP    3;
    * 
    : Checks last two bits for Register 2. Puts content into AC. Next step is on address 50. (ADD)
 45 : 111  00101110   00101111   00110000   00110001 : JIR[1:0]  46  47  48  49
 46 : 011 00 0 00 00 00 00 1 0001 1100 0101 00110010 :  ac := (  0+gr0); 
    :                                                : JMP   50;
 47 : 011 00 0 00 00 00 00 1 0001 1101 0101 00110010 :  ac := (  0+gr1); 
    :                                                : JMP   50;
 48 : 011 00 0 00 00 00 00 1 0001 1110 0101 00110010 :  ac := (  0+gr2); 
    :                                                : JMP   50;
 49 : 011 00 0 00 00 00 00 1 0001 1111 0101 00110010 :  ac := (  0+gr3); 
    :                                                : JMP   50;
    : Adds AC to Register 1 and puts the result in Register 1.
 50 : 110  00110011   00110100   00110101   00110110 : JIR[3:2]  51  52  53  54
 51 : 011 00 0 00 00 00 00 1 1100 1100 0001 00000011 : gr0 := ( ac+gr0); 
    :                                                : JMP    3;
 52 : 011 00 0 00 00 00 00 1 1101 1101 0001 00000011 : gr1 := ( ac+gr1); 
    :                                                : JMP    3;
 53 : 011 00 0 00 00 00 00 1 1110 1110 0001 00000011 : gr2 := ( ac+gr2); 
    :                                                : JMP    3;
 54 : 011 00 0 00 00 00 00 1 1111 1111 0001 00000011 : gr3 := ( ac+gr3); 
    :                                                : JMP    3;
    * 
    : Does 2s complement on Register 2 and stores in AC  (SUB)
 55 : 111  00111000   00111010   00111100   00111110 : JIR[1:0]  56  58  60  62
 56 : 000 00 0 11 00 00 00 1 1000 0101 1100 00000000 :  t1 := (gr0 NOT); 
 57 : 011 00 0 00 00 00 00 1 0001 1000 0110 01000000 :  ac := ( +1+ t1); 
    :                                                : JMP   64;
 58 : 000 00 0 11 00 00 00 1 1000 0101 1101 00000000 :  t1 := (gr1 NOT); 
 59 : 011 00 0 00 00 00 00 1 0001 1000 0110 01000000 :  ac := ( +1+ t1); 
    :                                                : JMP   64;
 60 : 000 00 0 11 00 00 00 1 1000 0101 1110 00000000 :  t1 := (gr2 NOT); 
 61 : 011 00 0 00 00 00 00 1 0001 1000 0110 01000000 :  ac := ( +1+ t1); 
    :                                                : JMP   64;
 62 : 000 00 0 11 00 00 00 1 1000 0101 1111 00000000 :  t1 := (gr3 NOT); 
 63 : 011 00 0 00 00 00 00 1 0001 1000 0110 01000000 :  ac := ( +1+ t1); 
    :                                                : JMP   64;
    : Adds negative value to Register 1 and stores in Register 1
 64 : 110  01000001   01000010   01000011   01000100 : JIR[3:2]  65  66  67  68
 65 : 011 00 0 00 00 00 00 1 1100 1100 0001 00000011 : gr0 := ( ac+gr0); 
    :                                                : JMP    3;
 66 : 011 00 0 00 00 00 00 1 1101 1101 0001 00000011 : gr1 := ( ac+gr1); 
    :                                                : JMP    3;
 67 : 011 00 0 00 00 00 00 1 1110 1110 0001 00000011 : gr2 := ( ac+gr2); 
    :                                                : JMP    3;
 68 : 011 00 0 00 00 00 00 1 1111 1111 0001 00000011 : gr3 := ( ac+gr3); 
    :                                                : JMP    3;
    * 
    : Checks bits 5 and 4 for register 1. Puts register 1 in PC. (BRR)
 70 : 111  01000111   01001000   01001001   01001010 : JIR[1:0]  71  72  73  74
 71 : 011 00 0 00 00 00 00 1 0000 1100 0101 00000011 :  pc := (  0+gr0); 
    :                                                : JMP    3;
 72 : 011 00 0 00 00 00 00 1 0000 1101 0101 00000011 :  pc := (  0+gr1); 
    :                                                : JMP    3;
 73 : 011 00 0 00 00 00 00 1 0000 1110 0101 00000011 :  pc := (  0+gr2); 
    :                                                : JMP    3;
 74 : 011 00 0 00 00 00 00 1 0000 1111 0101 00000011 :  pc := (  0+gr3); 
    :                                                : JMP    3;
    * 
    : Checks bits 5 and 4 for register 1. Stores PC+1 in Register 1 and does a branch instruction (address 20). (JSR) 
 75 : 110  01001100   01001101   01001110   01001111 : JIR[3:2]  76  77  78  79
 76 : 011 00 0 00 00 00 00 1 1100 0000 0110 00010100 : gr0 := ( +1+ pc); 
    :                                                : JMP   20;
 77 : 011 00 0 00 00 00 00 1 1101 0000 0110 00010100 : gr1 := ( +1+ pc); 
    :                                                : JMP   20;
 78 : 011 00 0 00 00 00 00 1 1110 0000 0110 00010100 : gr2 := ( +1+ pc); 
    :                                                : JMP   20;
 79 : 011 00 0 00 00 00 00 1 1111 0000 0110 00010100 : gr3 := ( +1+ pc); 
    :                                                : JMP   20;
    * 
    : Checks if bit 0 of PSW is 0. If 0 then increment PC because PSW is positive. Else do a branch instruction because PSW is negative (BNEG)  
 80 : 010 00 0 01 00 00 00 0 0000 0110 1011 01101010 : JZ (psw& +1)  106;
 81 : 011 00 0 00 00 00 00 0 0000 0000 0000 00010100 : JMP   20;
    * 
    : Checks if bit 0 of PSW is 0. If 0 then do a branch instruction because PSW is positive. Else.. do nothing and fetch another instruction because PC was already incremented 
 82 : 010 00 0 01 00 00 00 0 0000 0110 1011 00010100 : JZ (psw& +1)   20;
 83 : 011 00 0 00 00 00 00 0 0000 0000 0000 01101010 : JMP  106;
    * 
    : Shifts PSW right and stores result in t2. If rightmost bit of t2 is 0, then do nothing because PSW is not 0. Else do a branch instruction (BZ)
 84 : 000 00 0 00 01 00 00 1 1001 1011 0101 00000000 :  t2 := shr(  0+psw); 
 85 : 010 00 0 01 00 00 00 0 0000 1001 0110 01101010 : JZ ( +1& t2)  106;
 86 : 011 00 0 00 00 00 00 0 0000 0000 0000 00010100 : JMP   20;
    * 
    : Clears PSW register first 
    : Checks if zero, negative, or positive. Jumps to instruction that modifies the PSW register afterward.
 87 : 000 00 0 00 00 00 00 1 1011 0101 0101 00000000 : psw := (  0+  0); 
 88 : 111  01011001   01011100   01011111   01100010 : JIR[1:0]  89  92  95  98
    : gr0 (89)
 89 : 010 00 0 00 00 00 00 1 1001 1100 0101 01100110 :  t2 := (  0+gr0); 
    :                                                : JZ (  0+gr0)  102;
 90 : 001 00 0 00 00 00 00 1 1001 1100 0101 01100111 :  t2 := (  0+gr0); 
    :                                                : JN (  0+gr0)  103;
 91 : 011 00 0 00 00 00 00 1 1001 1100 0101 01101000 :  t2 := (  0+gr0); 
    :                                                : JMP  104;
    : gr1 (92)
 92 : 010 00 0 00 00 00 00 1 1001 1101 0101 01100110 :  t2 := (  0+gr1); 
    :                                                : JZ (  0+gr1)  102;
 93 : 001 00 0 00 00 00 00 1 1001 1101 0101 01100111 :  t2 := (  0+gr1); 
    :                                                : JN (  0+gr1)  103;
 94 : 011 00 0 00 00 00 00 1 1001 1101 0101 01101000 :  t2 := (  0+gr1); 
    :                                                : JMP  104;
    : gr2 (95)
 95 : 010 00 0 00 00 00 00 1 1001 1110 0101 01100110 :  t2 := (  0+gr2); 
    :                                                : JZ (  0+gr2)  102;
 96 : 001 00 0 00 00 00 00 1 1001 1110 0101 01100111 :  t2 := (  0+gr2); 
    :                                                : JN (  0+gr2)  103;
 97 : 011 00 0 00 00 00 00 1 1001 1110 0101 01101000 :  t2 := (  0+gr2); 
    :                                                : JMP  104;
    : gr3 (98) 
 98 : 010 00 0 00 00 00 00 1 1001 1111 0101 01100110 :  t2 := (  0+gr3); 
    :                                                : JZ (  0+gr3)  102;
 99 : 001 00 0 00 00 00 00 1 1001 1111 0101 01100111 :  t2 := (  0+gr3); 
    :                                                : JN (  0+gr3)  103;
100 : 011 00 0 00 00 00 00 1 1001 1111 0101 01101000 :  t2 := (  0+gr3); 
    :                                                : JMP  104;
    * 
    : If zero
102 : 011 00 0 00 10 00 00 1 1011 0101 0110 00000011 : psw := shl( +1+  0); 
    :                                                : JMP    3;
    : If negative
103 : 011 00 0 00 00 00 00 1 1011 0110 1011 00000011 : psw := (psw+ +1); 
    :                                                : JMP    3;
    : If positive 
104 : 011 00 0 00 00 00 00 1 1011 0101 0101 00000011 : psw := (  0+  0); 
    :                                                : JMP    3;
    * 
    : Increments PC for op codes BPOZ BNEG AND BZ
106 : 011 00 0 00 00 00 00 1 0000 0000 0110 00000011 :  pc := ( +1+ pc); 
    :                                                : JMP    3;
    * 
    :  MOVT - 00,01, and 11 is at address 112, 10 is at address 146 
109 : 110  01110000   01110000   10010100   01110000 : JIR[3:2] 112 112 148 112
    * 
    : Stores register into t1
112 : 111  01110001   01110010   01110011   01110100 : JIR[1:0] 113 114 115 116
113 : 011 00 0 00 00 00 00 1 1000 1100 0101 01110101 :  t1 := (  0+gr0); 
    :                                                : JMP  117;
114 : 011 00 0 00 00 00 00 1 1000 1101 0101 01110101 :  t1 := (  0+gr1); 
    :                                                : JMP  117;
115 : 011 00 0 00 00 00 00 1 1000 1110 0101 01110101 :  t1 := (  0+gr2); 
    :                                                : JMP  117;
116 : 011 00 0 00 00 00 00 1 1000 1111 0101 01110101 :  t1 := (  0+gr3); 
    :                                                : JMP  117;
    * 
    : address 1 
    : if Register mode, go to add Address 
    : if Deferred mode,  go to Deferred Address , then add Address 
    : if Byte displacement, go to Byte displacement address, then add Address. 
117 : 110  01111011   10000001   00000000   10000111 : JIR[3:2] 123 129   0 135
    * 
    : (add Address) (Put into register r1) 
    :  Add to corresponding register from t1
123 : 101  01111100   01111101   01111110   01111111 : JIR[5:4] 124 125 126 127
124 : 011 00 0 00 00 00 00 1 1100 1000 0101 10010001 : gr0 := (  0+ t1); 
    :                                                : JMP  145;
125 : 011 00 0 00 00 00 00 1 1101 1000 0101 10010001 : gr1 := (  0+ t1); 
    :                                                : JMP  145;
126 : 011 00 0 00 00 00 00 1 1110 1000 0101 10010001 : gr2 := (  0+ t1); 
    :                                                : JMP  145;
127 : 011 00 0 00 00 00 00 1 1111 1000 0101 10010001 : gr3 := (  0+ t1); 
    :                                                : JMP  145;
    : (Deferred Address)
    * 
129 : 000 00 0 00 00 01 00 0 0000 1000 0000 00000000 : mar :=  t1; 
130 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
131 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
132 : 000 00 1 00 00 00 00 1 1000 0101 0000 00000000 :  t1 := (mbr+  0); 
133 : 011 00 0 00 00 00 00 0 0000 0000 0000 01111011 : JMP  123;
    * 
    : (Byte Displacement Address) 
135 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
136 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
137 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
138 : 000 00 1 00 00 00 00 1 1001 0101 0000 00000000 :  t2 := (mbr+  0); 
139 : 000 00 0 00 00 00 00 1 1000 1000 1001 00000000 :  t1 := ( t2+ t1); 
140 : 000 00 0 00 00 01 00 0 0000 1000 0000 00000000 : mar :=  t1; 
141 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
142 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
143 : 000 00 1 00 00 00 00 1 1000 0101 0000 00000000 :  t1 := (mbr+  0); 
144 : 011 00 0 00 00 00 00 0 0000 0000 0000 01111011 : JMP  123;
    * 
    : Increments PC afterwards if necessary
145 : 110  10010010   10010010   10010011   10010011 : JIR[3:2] 146 146 147 147
146 : 011 00 0 00 00 00 00 0 0000 0000 0000 00000011 : JMP    3;
147 : 011 00 0 00 00 00 00 1 0000 0000 0110 00000011 :  pc := ( +1+ pc); 
    :                                                : JMP    3;
    * 
    : Literal (Puts Mem[PC] into t1 and goes to add Address) 
148 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
149 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
150 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
151 : 000 00 1 00 00 00 00 1 1000 0101 0000 00000000 :  t1 := (mbr+  0); 
152 : 011 00 0 00 00 00 00 0 0000 0000 0000 01111011 : JMP  123;
    * 
    : MOVF 
    : Stores r1 into t2
153 : 101  10011010   10011011   10011100   10011101 : JIR[5:4] 154 155 156 157
154 : 011 00 0 00 00 00 00 1 1001 1100 0101 10100000 :  t2 := (  0+gr0); 
    :                                                : JMP  160;
155 : 011 00 0 00 00 00 00 1 1001 1101 0101 10100000 :  t2 := (  0+gr1); 
    :                                                : JMP  160;
156 : 011 00 0 00 00 00 00 1 1001 1110 0101 10100000 :  t2 := (  0+gr2); 
    :                                                : JMP  160;
157 : 011 00 0 00 00 00 00 1 1001 1111 0101 10100000 :  t2 := (  0+gr3); 
    :                                                : JMP  160;
    * 
    : Stores r2 into t1
160 : 111  10100001   10100010   10100011   10100100 : JIR[1:0] 161 162 163 164
161 : 011 00 0 00 00 00 00 1 1000 1100 0101 10100110 :  t1 := (  0+gr0); 
    :                                                : JMP  166;
162 : 011 00 0 00 00 00 00 1 1000 1101 0101 10100110 :  t1 := (  0+gr1); 
    :                                                : JMP  166;
163 : 011 00 0 00 00 00 00 1 1000 1110 0101 10100110 :  t1 := (  0+gr2); 
    :                                                : JMP  166;
164 : 011 00 0 00 00 00 00 1 1000 1111 0101 10100110 :  t1 := (  0+gr3); 
    :                                                : JMP  166;
    * 
    : Checks which mode once again 
166 : 110  10100111   10101101   10110001   10110110 : JIR[3:2] 167 173 177 182
    * 
    : Register mode 
167 : 101  10101000   10101001   10101010   10101011 : JIR[5:4] 168 169 170 171
168 : 011 00 0 00 00 00 00 1 1100 1000 0101 00000011 : gr0 := (  0+ t1); 
    :                                                : JMP    3;
169 : 011 00 0 00 00 00 00 1 1101 1000 0101 00000011 : gr1 := (  0+ t1); 
    :                                                : JMP    3;
170 : 011 00 0 00 00 00 00 1 1110 1000 0101 00000011 : gr2 := (  0+ t1); 
    :                                                : JMP    3;
171 : 011 00 0 00 00 00 00 1 1111 1000 0101 00000011 : gr3 := (  0+ t1); 
    :                                                : JMP    3;
    * 
    : Deffered mode.. Loads Mem[Reg[r1]]
173 : 000 00 0 00 00 01 00 0 0000 1001 0000 00000000 : mar :=  t2; 
174 : 000 00 0 00 00 10 00 0 0000 1000 0101 00000000 : mbr := (  0+ t1); 
175 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
176 : 011 00 0 00 00 00 01 0 0000 0000 0000 00000011 : wr; JMP    3;
    * 
    : Literal 
177 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
178 : 000 00 0 00 00 10 00 0 0000 1000 0101 00000000 : mbr := (  0+ t1); 
179 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
180 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
181 : 011 00 0 00 00 00 00 1 0000 0000 0110 00000011 :  pc := ( +1+ pc); 
    :                                                : JMP    3;
    * 
    : Byte displacement
182 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
183 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
184 : 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 : rd; 
185 : 000 00 1 00 00 00 00 1 1001 1001 0000 00000000 :  t2 := (mbr+ t2); 
186 : 000 00 0 00 00 01 00 0 0000 1001 0000 00000000 : mar :=  t2; 
187 : 000 00 0 00 00 10 00 0 0000 1000 0101 00000000 : mbr := (  0+ t1); 
188 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
189 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
190 : 011 00 0 00 00 00 00 1 0000 0000 0110 00000011 :  pc := ( +1+ pc); 
    :                                                : JMP    3;
    * 
    :  Creates the number 9 to put into MAR
200 : 000 00 0 00 10 00 00 1 1010 0110 0110 00000000 :  t3 := shl( +1+ +1); 
201 : 000 00 0 00 10 00 00 1 1010 1010 0101 00000000 :  t3 := shl(  0+ t3); 
202 : 000 00 0 00 00 00 00 1 1010 1010 0110 00000000 :  t3 := ( +1+ t3); 
    :  Loads 9 into MAR 
203 : 000 00 0 00 00 01 00 0 0000 1010 0000 00000000 : mar :=  t3; 
    :  Loads PC into MBR
204 : 000 00 0 00 00 10 00 0 0000 0000 0101 00000000 : mbr := (  0+ pc); 
205 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
206 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
    : PC = 2 ( Int 1 )
207 : 000 00 0 00 00 00 00 1 0000 0110 0110 00000000 :  pc := ( +1+ +1); 
208 : 011 00 0 00 00 00 00 0 0000 0000 0000 00000011 : JMP    3;
    * 
    :  Creates the number 9 to put into MAR
230 : 000 00 0 00 10 00 00 1 1010 0110 0110 00000000 :  t3 := shl( +1+ +1); 
231 : 000 00 0 00 10 00 00 1 1010 1010 0101 00000000 :  t3 := shl(  0+ t3); 
232 : 000 00 0 00 00 00 00 1 1010 1010 0110 00000000 :  t3 := ( +1+ t3); 
    :  Loads 9 into MAR
233 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
    :  Loads PC into MBR
234 : 000 00 0 00 00 10 00 0 0000 0000 0101 00000000 : mbr := (  0+ pc); 
235 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
236 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
    : PC = 4 ( Int 2 )
237 : 000 00 0 00 10 00 00 1 0000 0110 0110 00000000 :  pc := shl( +1+ +1); 
238 : 011 00 0 00 00 00 00 0 0000 0000 0000 00000011 : JMP    3;
    * 
    :  Creates the number 9 to put into MAR
240 : 000 00 0 00 10 00 00 1 1010 0110 0110 00000000 :  t3 := shl( +1+ +1); 
241 : 000 00 0 00 10 00 00 1 1010 1010 0101 00000000 :  t3 := shl(  0+ t3); 
242 : 000 00 0 00 00 00 00 1 1010 1010 0110 00000000 :  t3 := ( +1+ t3); 
    :  Loads 9 into MAR
243 : 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 : mar :=  pc; 
    :  Loads PC into MBR
244 : 000 00 0 00 00 10 00 0 0000 0000 0101 00000000 : mbr := (  0+ pc); 
245 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
246 : 000 00 0 00 00 00 01 0 0000 0000 0000 00000000 : wr; 
    : PC = 6 ( Int 3 )
247 : 000 00 0 00 10 00 00 1 0000 0110 0110 00000000 :  pc := shl( +1+ +1); 
248 : 000 00 0 00 00 00 00 1 0000 0000 0110 00000000 :  pc := ( +1+ pc); 
249 : 000 00 0 00 00 00 00 1 0000 0000 0110 00000000 :  pc := ( +1+ pc); 
250 : 011 00 0 00 00 00 00 0 0000 0000 0000 00000011 : JMP    3;


=================== Main Memory Section =====================

    : Interrupt Vectors branches
  0 : 00000100 : 04=+004 : br
  1 : 00001010 : 0A=+010 :  <==>               brr gr2
    : Interrupt #1 : conclusion of a read request
  2 : 00000100 : 04=+004 : br
  3 : 01000000 : 40=+064 :  <==>               jsr gr0
    * 
    : Return code 
  8 : 00000100 : 04=+004 : br
    : First Instruction
    * 
    : gr1 to be address of RCVCS
 10 : 10011000 : 98=-104 :  <==>               movt gr1, (m2 gr0)
 11 : 11111100 : FC=-004 : movf (gr3 m3), gr0
    : gr2 to be the address of XMTCS
 12 : 10101000 : A8=-088 :  <==>               movt gr2, (m2 gr0)
 13 : 11111110 : FE=-002 : movf (gr3 m3), gr2
    :  gr3 character to be outputted: starts with lower case character 'a'
 14 : 10111000 : B8=-072 :  <==>               movt gr3, (m2 gr0)
 15 : 01100001 : 61=+097 : neg gr0
    : Sets code for RCVCS
 16 : 10001000 : 88=-120 : movt gr0, (m2 gr0)
 17 : 01000001 : 41=+065 :  <==>               jsr gr0
 18 : 11010100 : D4=-044 : movf (gr1 m1), gr0
    : Mem[gr2+1] <-gr3
 19 : 11101111 : EF=-017 : movf (gr2 m3), gr3
 20 : 00000001 : 01=+001 :  <==>               nop
    : start write cycle
 21 : 10001000 : 88=-120 : movt gr0, (m2 gr0)
 22 : 00000000 : 00=+000 :  <==>               hlt
 23 : 11100100 : E4=-028 : movf (gr2 m1), gr0
    : branch to 32
 24 : 00000100 : 04=+004 : br
 25 : 00100000 : 20=+032 :  <==>               sub gr0, gr0
    * 
    : Loop that waits for XMT to be ready. This loop is what prints the characters from gr3. gr0 stores the value from XMTCS 
 32 : 10000110 : 86=-122 : movt gr0, (m1 gr2)
 33 : 00001100 : 0C=+012 : tst gr0
 34 : 00000101 : 05=+005 : bneg
 35 : 00110000 : 30=+048 :  <==>               add gr0, gr0
    : If buffer is ready, then output gr3 and go back to infinite loop
 36 : 00000100 : 04=+004 : br
 37 : 00100000 : 20=+032 :  <==>               sub gr0, gr0
    * 
    : Mem[gr2+1] <-gr3
 48 : 11101111 : EF=-017 : movf (gr2 m3), gr3
 49 : 00000001 : 01=+001 :  <==>               nop
    : start write cycle
 50 : 10001000 : 88=-120 : movt gr0, (m2 gr0)
 51 : 00000000 : 00=+000 :  <==>               hlt
 52 : 11100100 : E4=-028 : movf (gr2 m1), gr0
    : Reloop back to the top loop
 53 : 00000100 : 04=+004 : br
 54 : 00100000 : 20=+032 :  <==>               sub gr0, gr0
    * 
    : Interrupt Vector 
    :  saves gr0 into location 201 to prevent loss of output from interrupt
 64 : 00000100 : 04=+004 : br
 65 : 11001000 : C8=-056 :  <==>               movf (gr0 m2), gr0
    * 
    : branch to 80
 66 : 00000100 : 04=+004 : br
 67 : 01010000 : 50=+080 :  <==>               clr gr0
    : Reads in input and puts in into gr0
    : gr0 <- Mem[gr1]
    : Tests gr0. If negative, go back to top loop
    * 
    : puts what is in RCVBUF into gr3-- gr3 <-Mem[gr2 +1]
 80 : 10111101 : BD=-067 : movt gr3, (m3 gr1)
 81 : 00000001 : 01=+001 :  <==>               nop
    : branch to 100 for Captial Letter test
 82 : 00000100 : 04=+004 : br
 83 : 01100100 : 64=+100 :  <==>               neg gr1
    * 
    : Tests for capital letters. 
    : put 61 into gr0. Subtract gr0 from gr3. If negative then, put 'A' into gr3. If zero or positive, put 'a' into gr3.
100 : 10001000 : 88=-120 : movt gr0, (m2 gr0)
101 : 01100001 : 61=+097 :  <==>               neg gr0
    : gr3 = gr3 -gr0
102 : 00101100 : 2C=+044 : sub gr3, gr0
    : TST gr3
103 : 00001111 : 0F=+015 : tst gr3
104 : 00000101 : 05=+005 : bneg
105 : 01111000 : 78=+120 :  <==>               inc gr2
106 : 00000100 : 04=+004 : br
107 : 01111101 : 7D=+125 :  <==>               inc gr3
    * 
    : put 'A' into gr3
120 : 10111000 : B8=-072 : movt gr3, (m2 gr0)
121 : 01000001 : 41=+065 :  <==>               jsr gr0
122 : 00000100 : 04=+004 : br
123 : 10001100 : 8C=-116 :  <==>               movt gr0, (m3 gr0)
    * 
    : put 'a' into gr3
125 : 10111000 : B8=-072 : movt gr3, (m2 gr0)
126 : 01100001 : 61=+097 :  <==>               neg gr0
127 : 00000100 : 04=+004 : br
128 : 10001100 : 8C=-116 :  <==>               movt gr0, (m3 gr0)
    * 
    : Sets code for RCVCS (resets reader)
140 : 10001000 : 88=-120 : movt gr0, (m2 gr0)
141 : 01000001 : 41=+065 :  <==>               jsr gr0
142 : 11010100 : D4=-044 : movf (gr1 m1), gr0
    : restores gr0 from Mem[201]
    : saves location in gr1 so we can access mem[201] again using register deffered addresssing
143 : 10011000 : 98=-104 : movt gr1, (m2 gr0)
144 : 11001001 : C9=-055 :  <==>               movf (gr0 m2), gr1
145 : 10000101 : 85=-123 : movt gr0, (m1 gr1)
    : restores the gr1 value 
146 : 10011000 : 98=-104 : movt gr1, (m2 gr0)
147 : 11111100 : FC=-004 :  <==>               movf (gr3 m3), gr0
    : returns to (pc=8)
148 : 00000100 : 04=+004 : br
149 : 00001000 : 08=+008 :  <==>               brr gr0

    * 
200 : 11001000 : C8=-056 : movf (gr0 m2), gr0
201 : 00000000 : 00=+000 :  <==>               hlt
    : branch to original location
202 : 00000100 : 04=+004 : br
203 : 01000010 : 42=+066 :  <==>               jsr gr0



=================== Input Specification Section =====================

 1000: hex 43 = `C'
 2800: hex 66 = `f'
 4600: hex 67 = `g'
 6400: hex 44 = `D'
 8200: hex 48 = `H'



=================== Tracing Output Section =====================

            :  pc:00=+000; psw:???????;  ir:04=+004; br
            : gr0:???????; gr1:???????; gr2:???????; gr3:???????; 
            : rcs:10000000 rbf:00=+000; xcs:10000000 xbf:00=+000; int: 000; 
     Mem[0] :  04=+004 0A=+010 04=+004 40=+064 ??????? ??????? ??????? ???????
     Mem[8] :  04=+004 ??????? 98=-104 FC=-004 A8=-088 FE=-002 B8=-072 61=+097
    Mem[16] :  88=-120 41=+065 D4=-044 EF=-017 01=+001 88=-120 00=+000 E4=-028
    Mem[24] :  04=+004 20=+032 ??????? ??????? ??????? ??????? ??????? ???????
    Mem[32] :  86=-122 0C=+012 05=+005 30=+048 04=+004 20=+032 ??????? ???????
    Mem[48] :  EF=-017 01=+001 88=-120 00=+000 E4=-028 04=+004 20=+032 ???????
    Mem[64] :  04=+004 C8=-056 04=+004 50=+080 ??????? ??????? ??????? ???????
    Mem[80] :  BD=-067 01=+001 04=+004 64=+100 ??????? ??????? ??????? ???????
    Mem[96] :  ??????? ??????? ??????? ??????? 88=-120 61=+097 2C=+044 0F=+015
   Mem[104] :  05=+005 78=+120 04=+004 7D=+125 ??????? ??????? ??????? ???????
   Mem[120] :  B8=-072 41=+065 04=+004 8C=-116 ??????? B8=-072 61=+097 04=+004
   Mem[128] :  8C=-116 ??????? ??????? ??????? ??????? ??????? ??????? ???????
   Mem[136] :  ??????? ??????? ??????? ??????? 88=-120 41=+065 D4=-044 98=-104
   Mem[144] :  C9=-055 85=-123 98=-104 FC=-004 04=+004 08=+008 ??????? ???????
   Mem[200] :  C8=-056 00=+000 04=+004 42=+066 ??????? ??????? ??????? ???????

