:  c  i a     s            c    b    a         
:  o  n m  a  h mm    e    c    b    a         
:  n  t u  l  f ba rw n    c    b    a         
:  d  r x  u  t rr dr c    c    b    a    addr4
:--- -- - -- -- -- -- - ---- ---- ---- --------
 011 00 0 00 00 00 00 1 0000 0101 0101 00000011 
#3 
:start of loop (read loop)
 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 
 000 00 0 00 00 00 10 0 0000 0000 0000 00000000
 000 00 0 00 00 00 10 0 0000 0000 0000 00000000 
 000 00 1 00 00 00 00 1 0011 0101 0000 00000000
 011 00 0 00 00 00 00 1 0000 0110 0000 00001010 
:Check Op Codes 
#10
 :Checks First Two bits. Goes to next line if 00 and branches to line 14 if 01 
 100 00001011 00001110 1101101 10011000 
 :Checks bits 5 and 4 of Mac0. Goes to ADD intruction if 11 and SUB if 10, Goes to 12 if 00  
 101 00001100 00000000 00110111 00101101
 :Checks if bits 2 and 3 are 00 01 10 11. Goes to 13 if 00, Goes to 15 if 01 . Goes to 70 if 10 (BRR), Goes to 87 if TST  
 110 00001101 00001111 01000110 01010111
 :Checks bits 0 and 1.   
 111 11111111 00010010 00010010 00010010 
#14
 :Checks bits 5 and 4 if bits 7 and 6 are 0 1 respectively. Branches to 28 if 01 (CLR), to 31 if NEG, 40 if INC, 
 101 01001011 00011010 00011111 00101000 
#15
 :Checks the 0 and 1 bit if bits 5 and 4 of the instruction are 01. If bits 0 and 1 are 00, jump to 20 (BR). If 01, then jump to 80. 
 111 00010100 01010000 01010010 01010100

#18
 :NOP operation 
 011 00 0 00 00 00 00 0 0000 0000 0000 00000011  
#20
 :Branches (BR) 
 000 00 0 00 00 01 00 0 0000 0000 0000 00000000 
 000 00 0 00 00 00 10 0 0000 0000 0000 00000000
 000 00 0 00 00 00 10 0 0000 0000 0000 00000000  
 000 00 1 00 00 00 00 1 1000 0101 0000 00000000 
 011 00 0 00 00 00 00 1 0000 0101 1000 00000011  
#26
 :Checks what bits 3 and 2 correspond to which register. Goes to 27 if 00, goes to 28 if 01 ..... goes to 30 if 11 (CLR)  
 110 00011011 00011100 00011101 00011110 
 011 00 0 00 00 00 00 1 1100 0101 0101 00000011
 011 00 0 00 00 00 00 1 1101 0101 0101 00000011 
 011 00 0 00 00 00 00 1 1110 0101 0101 00000011
 011 00 0 00 00 00 00 1 1111 0101 0101 00000011
#31 
 :Checks which general register bits 3 and 2 correspond to. Jumps to corresponding line and does 2s complement operation (NEG)
 110 00100000 00100010 00100100 00100110
 000 00 0 11 00 00 00 1 1100 0101 1100 00000000 
 011 00 0 00 00 00 00 1 1100 1100 0110 00000011
 000 00 0 11 00 00 00 1 1101 0101 1101 00000000
 011 00 0 00 00 00 00 1 1101 1101 0110 00000011
 000 00 0 11 00 00 00 1 1110 0101 1110 00000000
 011 00 0 00 00 00 00 1 1110 1110 0110 00000011
 000 00 0 11 00 00 00 1 1111 0101 1111 00000000
 011 00 0 00 00 00 00 1 1111 1111 0110 00000011
#40
 :Checks what general register bits 3 and 2 correspond to. Jumps to corresponding line and increments  (INC)
 110 00101001 00101010 00101011 00101100
 011 00 0 00 00 00 00 1 1100 1100 0110 00000011
 011 00 0 00 00 00 00 1 1101 1101 0110 00000011
 011 00 0 00 00 00 00 1 1110 1110 0110 00000011
 011 00 0 00 00 00 00 1 1111 1111 0110 00000011
#45
 :Checks last two bits for Register 2. Puts content into AC. Next step is on address 50. (ADD)
 111 00101110 00101111 00110000 00110001
 011 00 0 00 00 00 00 1 0001 1100 0101 00110010
 011 00 0 00 00 00 00 1 0001 1101 0101 00110010
 011 00 0 00 00 00 00 1 0001 1110 0101 00110010 
 011 00 0 00 00 00 00 1 0001 1111 0101 00110010
 :Adds AC to Register 1 and puts the result in Register 1.
 110 00110011 00110100 00110101 00110110  
 011 00 0 00 00 00 00 1 1100 1100 0001 00000011
 011 00 0 00 00 00 00 1 1101 1101 0001 00000011
 011 00 0 00 00 00 00 1 1110 1110 0001 00000011
 011 00 0 00 00 00 00 1 1111 1111 0001 00000011
#55
 :Does 2s complement on Register 2 and stores in AC  (SUB)
 111 00111000 00111010 00111100 00111110
 000 00 0 11 00 00 00 1 1000 0101 1100 00000000
 011 00 0 00 00 00 00 1 0001 1000 0110 01000000
 000 00 0 11 00 00 00 1 1000 0101 1101 00000000
 011 00 0 00 00 00 00 1 0001 1000 0110 01000000
 000 00 0 11 00 00 00 1 1000 0101 1110 00000000
 011 00 0 00 00 00 00 1 0001 1000 0110 01000000
 000 00 0 11 00 00 00 1 1000 0101 1111 00000000
 011 00 0 00 00 00 00 1 0001 1000 0110 01000000
 :Adds negative value to Register 1 and stores in Register 1
 110 01000001 01000010 01000011 01000100 
 011 00 0 00 00 00 00 1 1100 1100 0001 00000011
 011 00 0 00 00 00 00 1 1101 1101 0001 00000011
 011 00 0 00 00 00 00 1 1110 1110 0001 00000011
 011 00 0 00 00 00 00 1 1111 1111 0001 00000011
#70
 :Checks bits 5 and 4 for register 1. Puts register 1 in PC. (BRR)
 111 01000111 01001000 01001001 01001010
 011 00 0 00 00 00 00 1 0000 1100 0101 00000011
 011 00 0 00 00 00 00 1 0000 1101 0101 00000011 
 011 00 0 00 00 00 00 1 0000 1110 0101 00000011
 011 00 0 00 00 00 00 1 0000 1111 0101 00000011 
#75
 :Checks bits 5 and 4 for register 1. Stores PC+1 in Register 1 and does a branch instruction (address 20). (JSR) 
 110 01001100 01001101 01001110 01001111
 011 00 0 00 00 00 00 1 1100 0000 0110 00010100
 011 00 0 00 00 00 00 1 1101 0000 0110 00010100
 011 00 0 00 00 00 00 1 1110 0000 0110 00010100
 011 00 0 00 00 00 00 1 1111 0000 0110 00010100 
#80
:Checks if bit 0 of PSW is 0. If 0 then increment PC because PSW is positive. Else do a branch instruction because PSW is negative (BNEG)  
 010 00 0 01 00 00 00 0 0000 0110 1011 01101010
 011 00 0 00 00 00 00 0 0000 0000 0000 00010100
#82
 :Checks if bit 0 of PSW is 0. If 0 then do a branch instruction because PSW is positive. Else.. do nothing and fetch another instruction because PC was already incremented 
 010 00 0 01 00 00 00 0 0000 0110 1011 00010100
 011 00 0 00 00 00 00 0 0000 0000 0000 01101010 
#84
 :Shifts PSW right and stores result in t2. If rightmost bit of t2 is 0, then do nothing because PSW is not 0. Else do a branch instruction (BZ)
 000 00 0 00 01 00 00 1 1001 1011 0110 00000000 
 010 00 0 01 00 00 00 0 0000 1001 0110 01101010
 011 00 0 00 00 00 00 0 0000 0000 0000 00010100
#87
 :Clears PSW register first 
 :Checks if zero, negative, or positive. Jumps to instruction that modifies the PSW register afterward.
 000 00 0 00 00 00 00 1 1011 0101 0101 00000000 
 111 01011001 01011100 01011111 01100010
 :gr0 (89)
 010 00 0 00 00 00 00 1 1001 1100 0101 01100110 
 001 00 0 00 00 00 00 1 1001 1100 0101 01100111
 011 00 0 00 00 00 00 1 1001 1100 0101 01101000
 :gr1 (92)
 010 00 0 00 00 00 00 1 1001 1101 0101 01100110 
 001 00 0 00 00 00 00 1 1001 1101 0101 01100111
 011 00 0 00 00 00 00 1 1001 1101 0101 01101000
 :gr2 (95)
 010 00 0 00 00 00 00 1 1001 1110 0101 01100110
 001 00 0 00 00 00 00 1 1001 1110 0101 01100111
 011 00 0 00 00 00 00 1 1001 1110 0101 01101000
 :gr3 (98) 
 010 00 0 00 00 00 00 1 1001 1111 0101 01100110
 001 00 0 00 00 00 00 1 1001 1111 0101 01100111
 011 00 0 00 00 00 00 1 1001 1111 0101 01101000
#102
 :If zero
 011 00 0 00 10 00 00 1 1011 0101 0110 00000011
 :If negative
 011 00 0 00 00 00 00 1 1011 0110 1011 00000011 
 :If positive 
 011 00 0 00 00 00 00 1 1011 0101 0101 00000011
#106
:Increments PC for op codes BPOZ BNEG AND BZ
 011 00 0 00 00 00 00 1 0000 0000 0110 00000011 
#109
 : MOVT - 00,01, and 11 is at address 112, 10 is at address 146 
 110 01110000 01110000 10010010 01110000
#112
:Stores register into t1
 011 00 0 00 00 00 00 1 1000 1100 0101 01110100 
 011 00 0 00 00 00 00 1 1000 1101 0101 01110100
 011 00 0 00 00 00 00 1 1000 1110 0101 01110100
 011 00 0 00 00 00 00 1 1000 1111 0101 01110100
#116
 :address 1 
 :if Register mode, go to add Address 
 :if Deferred mode,  go to Deferred Address , then add Address 
 :if Byte displacement, go to Byte displacement address, then add Address. 
110 01110101 10000001 00000000 10000111
#123
:(add Address) (Put into register r1) 
: Add to corresponding register from t1
 101 01111100 01111101 01111110 01111111 
 011 00 0 00 00 00 00 1 1100 1000 0101 10001110 
 011 00 0 00 00 00 00 1 1101 1000 0101 10001110
 011 00 0 00 00 00 00 1 1110 1000 0101 10001110
 011 00 0 00 00 00 00 1 1111 1000 0101 10001110
:(Deferred Address)
#129
000 00 0 00 00 01 00 0 0000 1000 0000 00000000 
000 00 0 00 00 00 10 0 0000 0000 0000 00000000
000 00 0 00 00 00 10 0 0000 0000 0000 00000000
000 00 1 00 00 00 00 1 1000 0101 0000 00000000 
011 00 0 00 00 00 00 0 0000 0000 0000 01110101
#135
:(Byte Displacement Address) 
000 00 0 00 00 01 00 0 0000 0000 0000 00000000
000 00 0 00 00 00 10 0 0000 0000 0000 00000000
000 00 0 00 00 00 10 0 0000 0000 0000 00000000
000 00 1 00 00 00 00 0 1001 0101 0000 00000000  
000 00 0 00 00 00 00 1 1000 1000 1001 00000000
011 00 0 00 00 00 00 0 0000 0000 0000 01110101
#142
:Increments PC afterwards if necessary
101 10001111 10001111 10010000 10010000
011 00 0 00 00 00 00 0 0000 0000 0000 00000011
011 00 0 00 00 00 00 1 0000 0000 0110 00000011
#146
:Literal (Puts Mem[PC] into t1 and goes to add Address) 
000 00 0 00 00 01 00 0 0000 0000 0000 00000000
000 00 0 00 00 00 10 0 0000 0000 0000 00000000
000 00 0 00 00 00 10 0 0000 0000 0000 00000000
000 00 1 00 00 00 00 0 1000 0101 0000 00000000 
011 00 0 00 00 00 00 0 0000 0000 0000 01110101
#152 
:MOVF 
:Stores r1 into t2
101 10011010 10011011 10011000 10011001
011 00 0 00 00 00 00 0 1001 1100 0101 10100000
011 00 0 00 00 00 00 0 1001 1101 0101 10100000
011 00 0 00 00 00 00 0 1001 1110 0101 10100000
011 00 0 00 00 00 00 0 1001 1111 0101 10100000
#160
:Stores r2 into t1
111 10100001 10100010 10100011 10100101 
011 00 0 00 00 00 00 0 1000 1100 0101 10100110 
011 00 0 00 00 00 00 0 1000 1101 0101 10100110
011 00 0 00 00 00 00 0 1000 1110 0101 10100110
011 00 0 00 00 00 00 0 1000 1111 0101 10100110
#166
:Checks which mode once again 
110 10100001 10101101 10110001 10110100
#167
:Register mode 
111 101000010 10100011 10100100 10101001
011 00 0 00 00 00 00 1 1100 1001 0101 00000011
011 00 0 00 00 00 00 1 1101 1001 0101 00000011
011 00 0 00 00 00 00 1 1110 1001 0101 00000011
011 00 0 00 00 00 00 1 1111 1001 0101 00000011
#173
:Deffered mode.. Loads Mem[Reg[r1]]
000 00 0 00 00 01 00 0 0000 1001 0000 00000000
000 00 0 00 00 10 00 0 0000 1000 0101 00000000
011 00 0 00 00 00 01 0 0000 0000 0000 00000011
#177
:Literal 
000 00 0 00 00 10 00 0 0000 1000 0101 00000000 
000 00 0 00 00 00 01 0 0000 0000 0000 00000000
011 00 0 00 00 00 00 1 0000 0000 0110 00000011
#180
:Byte displacement
000 00 0 00 00 00 00 1 1001 1001 0000 00000000 
000 00 0 00 00 01 00 0 0000 1001 0000 00000000
000 00 0 00 00 10 00 0 0000 1000 0101 00000000
000 00 0 00 00 00 01 0 0000 0000 0000 00000000
011 00 0 00 00 00 00 1 0000 0000 0110 00000011






